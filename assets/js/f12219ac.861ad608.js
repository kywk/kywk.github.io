"use strict";(self.webpackChunkkywk_github_io=self.webpackChunkkywk_github_io||[]).push([["70339"],{98597:function(e,n,l){l.r(n),l.d(n,{metadata:()=>r,contentTitle:()=>a,default:()=>u,assets:()=>o,toc:()=>d,frontMatter:()=>i});var r=JSON.parse('{"id":"bootcamp/algorithm/bst","title":"DS: Binary Search Tree","description":"[DS] Binary Search Tree","source":"@site/moco/bootcamp/algorithm/bst.md","sourceDirName":"bootcamp/algorithm","slug":"/bootcamp/algorithm/bst","permalink":"/moco/bootcamp/algorithm/bst","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"Algorithm","permalink":"/moco/tags/algorithm"},{"inline":true,"label":"CS","permalink":"/moco/tags/cs"},{"inline":true,"label":"LeetCode","permalink":"/moco/tags/leet-code"}],"version":"current","frontMatter":{"title":"DS: Binary Search Tree","description":"[DS] Binary Search Tree","tags":["Algorithm","CS","LeetCode"],"date_created":"2022-05-29T16:00:00.000Z","image":"https://lh3.googleusercontent.com/pw/AL9nZEUA9Ifvd5Z8SXDWkeVB6AC4MPGwnXaL6kBXNPoXwOQQ2jOcZ1Jw_0p8TKK8C3ZX0e67_FOY15eDrm7aaXSQJcKtoUzC80SAQEHsaBy6qS2AqNNs5VUFNXBKm439y_1wkvmDl-PnL8ReojnIumNlEvOXBg=w800-no?authuser=0"},"sidebar":"tutorialSidebar","previous":{"title":"DS: AVL Tree","permalink":"/moco/bootcamp/algorithm/avl"},"next":{"title":"DS: Graph","permalink":"/moco/bootcamp/algorithm/graph"}}'),t=l("85893"),s=l("50065");let i={title:"DS: Binary Search Tree",description:"[DS] Binary Search Tree",tags:["Algorithm","CS","LeetCode"],date_created:new Date("2022-05-29T16:00:00.000Z"),image:"https://lh3.googleusercontent.com/pw/AL9nZEUA9Ifvd5Z8SXDWkeVB6AC4MPGwnXaL6kBXNPoXwOQQ2jOcZ1Jw_0p8TKK8C3ZX0e67_FOY15eDrm7aaXSQJcKtoUzC80SAQEHsaBy6qS2AqNNs5VUFNXBKm439y_1wkvmDl-PnL8ReojnIumNlEvOXBg=w800-no?authuser=0"},a="[DS] Binary Search Tree",o={},d=[{value:"Data Struct",id:"data-struct",level:2},{value:"w/ parent",id:"w-parent",level:3},{value:"w/o parent",id:"wo-parent",level:3},{value:"ADT Basic Operate",id:"adt-basic-operate",level:2},{value:"Search(v)",id:"searchv",level:3},{value:"Insert(v)",id:"insertv",level:3},{value:"Remove(v)",id:"removev",level:3},{value:"Find &amp; Travsal",id:"find--travsal",level:2},{value:"Min / Max",id:"min--max",level:3},{value:"Predecessor",id:"predecessor",level:3},{value:"Successor",id:"successor",level:3},{value:"Traversal",id:"traversal",level:2},{value:"Deep First Traversal",id:"deep-first-traversal",level:3},{value:"Inorder",id:"inorder",level:3},{value:"\u5C0F\u7D50",id:"\u5C0F\u7D50",level:2},{value:"See Also",id:"see-also",level:2}];function c(e){let n={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",tabitem:"tabitem",tabs:"tabs",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';"}),"\n",(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"ds-binary-search-tree",children:"[DS] Binary Search Tree"})}),"\n",(0,t.jsx)(n.p,{children:"Binary Search Tree \u57FA\u672C\u6982\u5FF5\u662F\u6BCF\u4E00\u500B\u7BC0\u9EDE\u6700\u591A\u6709\u5DE6\u53F3\u5404\u4E00\u500B\u5B50\u7BC0\u9EDE,\n\u5DE6\u5B50\u7BC0\u9EDE\u7684\u503C\u5C0F\u65BC\u81EA\u8EAB\u7BC0\u9EDE\u7684\u503C, \u53F3\u5B50\u7BC0\u9EDE\u5247\u5927\u65BC\u672C\u8EAB."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"A Binary Search Tree (BST) is a binary tree in which each vertex\nhas only up to 2 children that satisfies BST property:\nAll vertices in the left subtree of a vertex must hold a value\nsmaller than its own and all vertices in the right subtree of a\nvertex must hold a value larger than its own."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://visualgo.net/en/bst?slide=1",children:(0,t.jsx)(n.em,{children:"Binary Search Tree, AVL Tree - VisuAlgo"})})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["\u53EA\u8981\u7B26\u5408\u4E0A\u8FF0\u5B9A\u7FA9, \u7121\u8AD6\u6A39\u9577\u5F97\u5982\u4F55, \u90FD\u7B26\u5408 BST \u7684\u898F\u7BC4.",(0,t.jsx)(n.br,{}),"\nBST \u5728\u641C\u5C0B\u8CC7\u6599\u4E0A\u6709 O(log N) \u8907\u96DC\u5EA6\u512A\u52E2, \u662F\u5F88\u5E38\u4F7F\u7528\u7684\u57FA\u790E\u8CC7\u6599\u7D50\u69CB."]}),"\n",(0,t.jsx)(n.h2,{id:"data-struct",children:"Data Struct"}),"\n",(0,t.jsx)(n.p,{children:"\u4E00\u822C\u7528\u8CC7\u6599\u7D50\u69CB\u4F86\u8868\u793A\u4E8C\u5143\u6A39\u7BC0\u9EDE\u6709\u5169\u7A2E\u65B9\u5F0F:"}),"\n",(0,t.jsx)(n.h3,{id:"w-parent",children:"w/ parent"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"struct node {\n    int value;\n    node *parent;\n    node *l_child;\n    node *r_child;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"wo-parent",children:"w/o parent"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"struct node {\n    int value;\n    node *l_child;\n    node *r_child;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"\u5169\u8005\u7684\u5DEE\u5225\u81F3\u5728\u65BC\u7BC0\u9EDE\u5B9A\u7FA9\u4E2D\u662F\u5426\u5305\u542B\u6307\u5411\u7236\u7BC0\u9EDE\u7684\u5C6C\u6027, \u7BC0\u9EDE\u9593\u7684\u9023\u7D50\u662F\u55AE\u5411\u9084\u662F\u96D9\u5411\u95DC\u4FC2."}),"\n",(0,t.jsx)(n.p,{children:"\u5305\u542B\u7236\u7BC0\u9EDE\u7684\u8CC7\u6599\u7D50\u69CB\u96D9\u5411\u9023\u7D50\u7684\u5C6C\u6027, \u5F9E\u4E8C\u5143\u6A39\u4E2D\u4EFB\u4E00\u7BC0\u9EDE\u5DE1\u8A2A, \u7686\u53EF\u5B8C\u6574\u9084\u539F\u5B8C\u6574\u4E8C\u5143\u6A39\u7684\u8CC7\u6599.\n\u82E5\u6709\u9700\u8981, \u53EF\u4EE5\u5F9E\u4EFB\u4F55\u4E00\u500B\u7BC0\u9EDE\u958B\u59CB\u5C0B\u8A2A, \u7121\u9808\u6BCF\u4E00\u6B21\u90FD\u5FC5\u9808\u5F9E Root \u958B\u59CB\u5DE1\u8A2A.\n\u4F46\u7576\u4FEE\u6539\u4E8C\u5143\u6A39\u4E2D\u7684\u8CC7\u6599\u6642, \u9700\u8981\u6CE8\u610F\u7DAD\u8B77\u7BC0\u9EDE\u4E2D\u7684\u9023\u7D50\u95DC\u4FC2, \u5C24\u5176\u662F\u7236\u7BC0\u9EDE\u7684\u9023\u7D50."}),"\n",(0,t.jsx)(n.p,{children:"\u800C\u4E0D\u5305\u542B\u7236\u7BC0\u9EDE\u7684\u7D50\u69CB\u4E2D, API \u547C\u53EB\u57FA\u672C\u4E0A\u90FD\u5FC5\u9808\u5F9E Root \u958B\u59CB\u5DE1\u8A2A.\n\u4F46\u76F8\u5C0D\u4FEE\u6539\u8CC7\u6599\u6642, \u53EA\u9700\u8981\u8655\u7406\u5B50\u7BC0\u9EDE\u7684\u55AE\u5411\u9023\u7D50\u95DC\u4FC2, \u7A0B\u5F0F\u7D50\u69CB\u90FD\u6BD4\u8F03\u7C21\u55AE."}),"\n",(0,t.jsx)(n.p,{children:"\u5169\u8005\u5404\u6709\u512A\u7F3A\u9EDE, \u4F9D\u5BE6\u52D9\u9700\u6C42\u6C7A\u5B9A. \u672C\u7BC7\u9078\u7528\u4E0D\u5305\u62EC\u7236\u9023\u7D50\u7684\u7D50\u69CB."}),"\n",(0,t.jsxs)(n.tabs,{children:["\n  ",(0,t.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type IBSTNode interface {\n  search(int) bool\n  insert(int)\n  remove(int) IBSTNode\n  findMin() int\n  findMax() int\n  findPredecessor(int) int\n  findSuccessor(int) int\n  inorder(*[]int)\n}\n\ntype BST struct {\n  root IBSTNode\n}\n\ntype BSTNode struct {\n  value int\n  left  *BSTNode\n  right *BSTNode\n}\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class BST {\n  constructor(data) {\n    this.root = null\n    if (typeof(data) === 'number') {\n      this.root = new BSTNode(data)\n    } else if (Array.isArray(data)) {\n      this.root = new BSTNode(data[0])\n      for (let i = 1; i < data.length; i++)\n        this.insert(data[i])\n    }\n  }\n}\n\nclass BSTNode {\n  constructor(data) {\n    this.value = data\n    this.left = null\n    this.right = null\n  }\n}\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export class BST {\n  root: BSTNode | null\n\n  constructor(data: number | Array<number> | null) {\n    this.root = null\n    if (typeof(data) === 'number') {\n      this.root = new BSTNode(data)\n    } else if (Array.isArray(data)) {\n      this.root = new BSTNode(data[0])\n      for (let i = 1; i < data.length; i++)\n        this.insert(data[i])\n    }\n  }\n}\n\ntype IBSTNode = BSTNode | null\nexport class BSTNode {\n  value: number\n  left: IBSTNode\n  right: IBSTNode\n\n  constructor(data: number) {\n    this.value = data\n    this.left = null\n    this.right = null\n  }\n}\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class BST:\n    def __init__(self, data):\n        self._root = None\n        if isinstance(data, int):\n            self._root = BSTNode(data)\n        elif isinstance(data, list):\n            self._root = BSTNode(data[0])\n            for i in range(1, len(data), 1):\n                self.insert(data[i])\n\nclass BSTNode:\n    def __init__(self, data):\n        self.value = data\n        self.left = None\n        self.right = None\n"})}),"\n  "]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"adt-basic-operate",children:"ADT Basic Operate"}),"\n",(0,t.jsx)(n.p,{children:"BST (and especially balanced BST like AVL Tree) is an efficient\ndata structure to implement a certain kind of Table (or Map)\nAbstract Data Type (ADT)."}),"\n",(0,t.jsx)(n.p,{children:"A Table ADT must support at least the following three operations\nas efficient as possible:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Search(v) \u2014 determine if v exists in the ADT or not,"}),"\n",(0,t.jsx)(n.li,{children:"Insert(v) \u2014 insert v into the ADT,"}),"\n",(0,t.jsx)(n.li,{children:"Remove(v) \u2014 remove v from the ADT."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"searchv",children:"Search(v)"}),"\n",(0,t.jsxs)(n.tabs,{children:["\n  ",(0,t.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (n *BSTNode) search(val int) bool {\n  if n == nil { return false }\n  if n.value > val {\n    return n.left.search(val)\n  } else if n.value < val {\n    return n.right.search(val)\n  } else {\n    return true\n  }\n}\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"  // class BSTNode\n  search(val) {\n    if (this.value === val)\n      return true\n    if (this.value > val)\n      return this.left === null ? false : this.left.search(val)\n    else\n      return this.right === null ? false : this.right.search(val)\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"  // class BSTNode\n  public search(val: number): boolean {\n    if (this.value === val)\n      return true\n    if (this.value > val)\n      return this.left === null ? false : this.left.search(val)\n    else\n      return this.right === null ? false : this.right.search(val)\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"    # class BSTNode\n    def search(self, val):\n        if self.value == val:\n            return True\n        if val < self.value:\n            return False if self.left == None else self.left.search(val)\n        else:\n            return False if self.right == None else self.right.search(val)\n\n"})}),"\n  "]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"insertv",children:"Insert(v)"}),"\n",(0,t.jsxs)(n.tabs,{children:["\n  ",(0,t.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (bst *BST) Insert(val int) {\n  if bst.root == nil { return }\n  bst.root = bst.root.insert(val)\n}\n\nfunc (n *BSTNode) insert(val int) IBSTNode {\n  return n.insertHelper(val)\n}\n\nfunc (n *BSTNode) insertHelper(val int) *BSTNode {\n  if n == nil { return newBSTNode(val) }\n\n  if val < n.value { n.left = n.left.insertHelper(val) } \n  else { n.right = n.right.insertHelper(val) }\n  return n\n}\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"  // class BST\n  insert(val) {\n    if (this.root === null) return\n    this.root = this.root.insert(val)\n  }\n\n  // class BSTNode\n  insert(val) {\n    return BSTNode._insertHelper(val, this)\n  }\n\n  static _insertHelper(val, node) {\n    if (node === null) return new BSTNode(val)\n\n    if (val < node.value)\n      node.left = BSTNode._insertHelper(val, node.left)\n    else\n      node.right = BSTNode._insertHelper(val, node.right)\n    return node\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"  // class BST\n  insert(val: number) {\n    if (this.root === null) return\n    this.root = this.root.insert(val)\n  }\n\n  // class BSTNode\n  public insert(val: number): IBSTNode {\n    return BSTNode.insertHelper(val, this)\n  }\n\n  static insertHelper(val: number, node: IBSTNode): IBSTNode {\n    if (node === null) return new BSTNode(val)\n\n    if (val < node.value)\n      node.left = BSTNode.insertHelper(val, node.left)\n    else\n      node.right = BSTNode.insertHelper(val, node.right)\n    return node\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"    # class BST\n    def insert(self, val):\n        if self._root is None:\n            self._root = BSTNode(val)\n        self._root = self._root.insert(val)\n\n    # class BSTNode\n    def insert(self, val):\n        return BSTNode.insert_helper(val, self)\n\n    @classmethod\n    def insert_helper(cls, val, node):\n        if node == None:\n            return BSTNode(val)\n\n        if val < node.value:\n            node.left = BSTNode.insert_helper(val, node.left)\n        else:\n            node.right = BSTNode.insert_helper(val, node.right)\n        return node \n"})}),"\n  "]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"removev",children:"Remove(v)"}),"\n",(0,t.jsxs)(n.tabs,{children:["\n  ",(0,t.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (bst *BST) Remove(val int) {\n  if bst.root == nil { return }\n  bst.root = bst.root.remove(val)\n}\n\nfunc (n *BSTNode) remove(val int) IBSTNode {\n  return n.removeHelper(val)\n}\n\nfunc (n *BSTNode) removeHelper(val int) *BSTNode {\n  if n == nil { return nil }\n\n  if n.value > val {\n    n.left = n.left.removeHelper(val)\n  } else if n.value < val {\n    n.right = n.right.removeHelper(val)\n  } else {\n    if n.left != nil && n.right != nil {\n      successor := n.right.findMin()\n      n.value = successor\n      n.right = n.right.removeHelper(successor)\n    } else if n.left != nil {\n      n = n.left\n    } else if n.right != nil {\n      n = n.right\n    } else {\n      return nil\n    }\n  }\n  return n\n}\n\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"  // class BST\n  remove(val) {\n    if (this.root === null) return\n    this.root = this.root.remove(val)\n  }\n\n  // class BSTNode\n  remove(val) {\n    return BSTNode._removeHelper(val, this)\n  }\n\n  static _removeHelper(val, node) {\n    if (node === null) return null\n\n    if (val < node.value) {\n      node.left = BSTNode._removeHelper(val, node.left)\n    } else if (node.value < val) {\n      node.right = BSTNode._removeHelper(val, node.right)\n    } else {\n      if ((node.left === null) && (node.right === null))\n        return null\n      else if (node.left === null)\n        result = node.right\n      else if (node.right === null)\n        result = node.left\n      else {\n        let successor = node.right.findMin()\n        node.value = successor\n        node.right = BSTNode._removeHelper(successor, node.right)\n      }\n    }\n    return node\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"  // class BST\n  remove(val: number) {\n    if (this.root === null) return\n    this.root = this.root.remove(val)\n  }\n\n  // class BSTNode\n  public remove(val: number): IBSTNode {\n    return BSTNode.removeHelper(val, this)\n  }\n\n  static removeHelper(val: number, node: IBSTNode): IBSTNode {\n    if (node === null)\n      return null\n\n    if (val < node.value) {\n      node.left = BSTNode.removeHelper(val, node.left)\n    } else if (node.value < val) {\n      node.right = BSTNode.removeHelper(val, node.right)\n    } else {\n      if ((node.left === null) && (node.right === null))\n        return null\n      else if (node.left === null)\n        node = node.right\n      else if (node.right === null)\n        node = node.left\n      else {\n        let successor = node.right.findMin()\n        node.value = successor\n        node.right = BSTNode.removeHelper(successor, node.right)\n      }\n    }\n    return node\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"    # class BST\n    def remove(self, val):\n        if self._root is None:\n            return\n        self._root = self._root.remove(val)\n\n    # class BSTNode\n    def remove(self, val):\n        return BSTNode.remove_helper(val, self)\n\n    @classmethod\n    def remove_helper(cls, val, node):\n        if node == None:\n            return None\n\n        if val < node.value:\n            node.left = BSTNode.remove_helper(val, node.left)\n        elif node.value < val:\n            node.right = BSTNode.remove_helper(val, node.right)\n        else:\n            if node.left == None and node.right == None:\n                return None\n            elif node.left == None:\n                node = node.right\n            elif node.right == None:\n                node = node.left\n            else:\n                successor = node.right.find_min()\n                node.value = successor\n                node.right = BSTNode.remove_helper(successor, node.right)\n        return node\n"})}),"\n  "]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"find--travsal",children:"Find & Travsal"}),"\n",(0,t.jsx)(n.h3,{id:"min--max",children:"Min / Max"}),"\n",(0,t.jsxs)(n.tabs,{children:["\n  ",(0,t.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (n *BSTNode) findMin() int {\n  if n.left == nil { return n.value } \n  else { return n.left.findMin() }\n}\n\nfunc (n *BSTNode) findMax() int {\n  if n.right == nil { return n.value } \n  else { return n.right.findMax() }\n}\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"  findMin() {\n    return this.left === null ?  this.value : this.left.findMin()\n  }\n\n  findMax() {\n    return this.right === null ? this.value : this.right.findMax()\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"  public findMin(): number {\n    return this.left === null ?  this.value : this.left.findMin()\n  }\n\n  public findMax(): number {\n    return this.right === null ? this.value : this.right.findMax()\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"    def find_min(self):\n        return self.value if self.left == None else self.left.find_min()\n\n    def find_max(self):\n        return self.value if self.right == None else self.right.find_max()-\n"})}),"\n  "]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"predecessor",children:"Predecessor"}),"\n",(0,t.jsxs)(n.tabs,{children:["\n  ",(0,t.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (n *BSTNode) findPredecessor(val int) int {\n  predecessor := NOTFOUND\n  node := n\n  for node != nil && node.value != val {\n    if node.value < val {\n      predecessor = node.value\n      node = node.right\n    } else { node = node.left }\n  }\n  if node == nil { return NOTFOUND }\n  if node.left != nil { return node.left.findMax() } \n  else { return predecessor }\n}\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"  findPredecessor(val) {\n    let predecessor = NOT_FOUND\n    let node = this\n    while ((node !== null) && (node.value !== val)) {\n      if (node.value < val) {\n        predecessor = node.value\n        node = node.right\n      } else \n        node = node.left\n    }\n    if (node === null)\n      return NOT_FOUND\n    if (node.left !== null)\n      return node.left.findMax()\n    else\n      return predecessor\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"  public findPredecessor(val: number): number{\n    return BSTNode.findPredecessor(val, this)\n  }\n\n  static findPredecessor(val: number, currentNode: IBSTNode): number {\n    let predecessor = NOT_FOUND\n    let node = currentNode\n    while ((node !== null) && (node.value !== val)) {\n      if (node.value < val) {\n        predecessor = node.value\n        node = node.right\n      } else {\n        node = node.left\n      }\n    }\n\n    if (node === null)\n      return NOT_FOUND\n    if (node.left !== null)\n      return node.left.findMax()\n    else\n      return predecessor\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"    def find_predecessor(self, val):\n        predecessor = NOT_FOUND\n        node = self\n        while node != None and node.value != val:\n            if node.value < val:\n                predecessor = node.value\n                node = node.right\n            else:\n                node = node.left\n\n        if node == None:\n            return NOT_FOUND\n        if node.left != None:\n            return node.left.find_max()\n        else:\n            return predecessor\n"})}),"\n  "]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"successor",children:"Successor"}),"\n",(0,t.jsxs)(n.tabs,{children:["\n  ",(0,t.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (n *BSTNode) findSuccessor(val int) int {\n  successor := NOTFOUND\n  node := n\n  for node != nil && node.value != val {\n    if node.value > val {\n      successor = node.value\n      node = node.left\n    } else { node = node.right }\n  }\n  if node == nil { return NOTFOUND }\n  if node.right != nil { return node.right.findMin() } \n  else { return successor }\n}\n\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"  findSuccessor(val) {\n    let successor = NOT_FOUND\n    let node = this\n    while ((node !== null) && (node.value !== val)) {\n      if (node.value > val) {\n        successor = node.value\n        node = node.left\n      } else \n        node = node.right\n    }\n    if (node === null)\n      return NOT_FOUND\n    if (node.right !== null)\n      return node.right.findMin()\n    else\n      return successor\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"  public findSuccessor(val: number): number{\n    return BSTNode.findSuccessor(val, this)\n  }\n\n  static findSuccessor(val: number, currentNode: IBSTNode): number {\n    let successor = NOT_FOUND\n    let node = currentNode\n    while ((node !== null) && (node.value !== val)) {\n      if (node.value > val) {\n        successor = node.value\n        node = node.left\n      } else {\n        node = node.right\n      }\n    }\n\n    if (node === null)\n      return NOT_FOUND\n    if (node.right !== null)\n      return node.right.findMin()\n    else\n      return successor\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"    def find_successor(self, val):\n        successor = NOT_FOUND\n        node = self\n        while node != None and node.value != val:\n            if val < node.value:\n                successor = node.value\n                node = node.left\n            else:\n                node = node.right\n\n        if node == None:\n            return NOT_FOUND\n        if node.right != None:\n            return node.right.find_min()\n        else:\n            return successor\n"})}),"\n  "]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"traversal",children:"Traversal"}),"\n",(0,t.jsx)(n.h3,{id:"deep-first-traversal",children:"Deep First Traversal"}),"\n",(0,t.jsx)(n.p,{children:"... TBD..."}),"\n",(0,t.jsx)(n.h3,{id:"inorder",children:"Inorder"}),"\n",(0,t.jsx)(n.p,{children:"An Inorder Traversal of this BST to obtain a list of sorted\nintegers inside this BST."}),"\n",(0,t.jsx)(n.p,{children:"Inorder Traversal is a recursive method whereby we visit\nthe left subtree first, exhausts all items in the left subtree,\nvisit the current root, before exploring the right subtree and\nall items in the right subtree."}),"\n",(0,t.jsxs)(n.tabs,{children:["\n  ",(0,t.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"func (bst *BST) Inorder() []int {\n  if bst.root == nil { return nil }\n  result := make([]int, 0)\n  bst.root.inorder(&result)\n  return result\n}\n\nfunc (n *BSTNode) inorder(buf *[]int) {\n  if n == nil { return }\n  n.left.inorder(buf)\n  *buf = append(*buf, n.value)\n  n.right.inorder(buf)\n}\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"  inorder() {\n    let result = []\n    if (this.left !== null)\n      result = result.concat(this.left.inorder())\n    result.push(this.value)\n    if (this.right !== null)\n      result = result.concat(this.right.inorder())\n    return result\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"  public inorder(): Array<number> {\n    let result: Array<number> = new Array()\n    if (this.left !== null)\n      result = result.concat(this.left.inorder())\n    result.push(this.value)\n    if (this.right !== null)\n      result = result.concat(this.right.inorder())\n    return result\n  }\n"})}),"\n  "]}),"\n  ",(0,t.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"    def inorder(self):\n        result = []\n        if self.left != None:\n            result.extend(self.left.inorder())\n        result.append(self.value)\n        if self.right != None:\n            result.extend(self.right.inorder())\n        return result\n"})}),"\n  "]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"\u5C0F\u7D50",children:"\u5C0F\u7D50"}),"\n",(0,t.jsxs)(n.p,{children:["\u548C ",(0,t.jsx)(n.a,{href:"/moco/bootcamp/algorithm/heap",children:"Binary Heap"})," \u76F8\u6BD4, BST \u4E2D\u7A0B\u5F0F\u905E\u8FF4\u53EF\u80FD\u6703\u4FEE\u6539\u5230\u7269\u4EF6\u672C\u8EAB.\n\u547C\u53EB\u548C\u56DE\u50B3\u7684\u7269\u4EF6\u8655\u7406\u4E0A\u9700\u8981\u6BD4\u8F03\u6CE8\u610F."]}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://visualgo.net/en/bst",children:"Binary Search Tree, AVL Tree - VisuAlgo"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://levelup.gitconnected.com/58f9126eb36b",children:"Binary Search Trees in Go. Introduction | by Puneeth S | Level Up Coding"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://arsenekuo.com/post/2021/12/13/implementation-of-bst-in-javascript",children:"\u7528 JavaScript \u5BE6\u4F5C\u4E8C\u5143\u641C\u5C0B\u6A39\uFF08Binary Search Tree\uFF09 | Arsene's Alibi"})}),"\n"]})]})}function u(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},50065:function(e,n,l){l.d(n,{Z:function(){return a},a:function(){return i}});var r=l(67294);let t={},s=r.createContext(t);function i(e){let n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);