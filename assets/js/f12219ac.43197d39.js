"use strict";(self.webpackChunkkywk_github_io=self.webpackChunkkywk_github_io||[]).push([[61294],{3948:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var r=l(85893),t=l(11151);const s={title:"DS: Binary Search Tree",description:"[DS] Binary Search Tree",tags:["Algorithm","CS","LeetCode"],date_created:new Date("2022-05-29T16:00:00.000Z"),image:"https://lh3.googleusercontent.com/pw/AL9nZEUA9Ifvd5Z8SXDWkeVB6AC4MPGwnXaL6kBXNPoXwOQQ2jOcZ1Jw_0p8TKK8C3ZX0e67_FOY15eDrm7aaXSQJcKtoUzC80SAQEHsaBy6qS2AqNNs5VUFNXBKm439y_1wkvmDl-PnL8ReojnIumNlEvOXBg=w800-no?authuser=0"},i="[DS] Binary Search Tree",a={id:"bootcamp/algorithm/bst",title:"DS: Binary Search Tree",description:"[DS] Binary Search Tree",source:"@site/moco/bootcamp/algorithm/bst.md",sourceDirName:"bootcamp/algorithm",slug:"/bootcamp/algorithm/bst",permalink:"/moco/bootcamp/algorithm/bst",draft:!1,unlisted:!1,tags:[{label:"Algorithm",permalink:"/moco/tags/algorithm"},{label:"CS",permalink:"/moco/tags/cs"},{label:"LeetCode",permalink:"/moco/tags/leet-code"}],version:"current",frontMatter:{title:"DS: Binary Search Tree",description:"[DS] Binary Search Tree",tags:["Algorithm","CS","LeetCode"],date_created:"2022-05-29T16:00:00.000Z",image:"https://lh3.googleusercontent.com/pw/AL9nZEUA9Ifvd5Z8SXDWkeVB6AC4MPGwnXaL6kBXNPoXwOQQ2jOcZ1Jw_0p8TKK8C3ZX0e67_FOY15eDrm7aaXSQJcKtoUzC80SAQEHsaBy6qS2AqNNs5VUFNXBKm439y_1wkvmDl-PnL8ReojnIumNlEvOXBg=w800-no?authuser=0"},sidebar:"tutorialSidebar",previous:{title:"DS: AVL Tree",permalink:"/moco/bootcamp/algorithm/avl"},next:{title:"DS: Graph",permalink:"/moco/bootcamp/algorithm/graph"}},o={},d=[{value:"Data Struct",id:"data-struct",level:2},{value:"w/ parent",id:"w-parent",level:3},{value:"w/o parent",id:"wo-parent",level:3},{value:"ADT Basic Operate",id:"adt-basic-operate",level:2},{value:"Search(v)",id:"searchv",level:3},{value:"Insert(v)",id:"insertv",level:3},{value:"Remove(v)",id:"removev",level:3},{value:"Find &amp; Travsal",id:"find--travsal",level:2},{value:"Min / Max",id:"min--max",level:3},{value:"Predecessor",id:"predecessor",level:3},{value:"Successor",id:"successor",level:3},{value:"Traversal",id:"traversal",level:2},{value:"Deep First Traversal",id:"deep-first-traversal",level:3},{value:"Inorder",id:"inorder",level:3},{value:"\u5c0f\u7d50",id:"\u5c0f\u7d50",level:2},{value:"See Also",id:"see-also",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",tabitem:"tabitem",tabs:"tabs",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';"}),"\n",(0,r.jsx)(n.h1,{id:"ds-binary-search-tree",children:"[DS] Binary Search Tree"}),"\n",(0,r.jsx)(n.p,{children:"Binary Search Tree \u57fa\u672c\u6982\u5ff5\u662f\u6bcf\u4e00\u500b\u7bc0\u9ede\u6700\u591a\u6709\u5de6\u53f3\u5404\u4e00\u500b\u5b50\u7bc0\u9ede,\n\u5de6\u5b50\u7bc0\u9ede\u7684\u503c\u5c0f\u65bc\u81ea\u8eab\u7bc0\u9ede\u7684\u503c, \u53f3\u5b50\u7bc0\u9ede\u5247\u5927\u65bc\u672c\u8eab."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"A Binary Search Tree (BST) is a binary tree in which each vertex\nhas only up to 2 children that satisfies BST property:\nAll vertices in the left subtree of a vertex must hold a value\nsmaller than its own and all vertices in the right subtree of a\nvertex must hold a value larger than its own."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://visualgo.net/en/bst?slide=1",children:(0,r.jsx)(n.em,{children:"Binary Search Tree, AVL Tree - VisuAlgo"})})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["\u53ea\u8981\u7b26\u5408\u4e0a\u8ff0\u5b9a\u7fa9, \u7121\u8ad6\u6a39\u9577\u5f97\u5982\u4f55, \u90fd\u7b26\u5408 BST \u7684\u898f\u7bc4.",(0,r.jsx)(n.br,{}),"\nBST \u5728\u641c\u5c0b\u8cc7\u6599\u4e0a\u6709 O(log N) \u8907\u96dc\u5ea6\u512a\u52e2, \u662f\u5f88\u5e38\u4f7f\u7528\u7684\u57fa\u790e\u8cc7\u6599\u7d50\u69cb."]}),"\n",(0,r.jsx)(n.h2,{id:"data-struct",children:"Data Struct"}),"\n",(0,r.jsx)(n.p,{children:"\u4e00\u822c\u7528\u8cc7\u6599\u7d50\u69cb\u4f86\u8868\u793a\u4e8c\u5143\u6a39\u7bc0\u9ede\u6709\u5169\u7a2e\u65b9\u5f0f:"}),"\n",(0,r.jsx)(n.h3,{id:"w-parent",children:"w/ parent"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct node {\n    int value;\n    node *parent;\n    node *l_child;\n    node *r_child;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"wo-parent",children:"w/o parent"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct node {\n    int value;\n    node *l_child;\n    node *r_child;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u5169\u8005\u7684\u5dee\u5225\u81f3\u5728\u65bc\u7bc0\u9ede\u5b9a\u7fa9\u4e2d\u662f\u5426\u5305\u542b\u6307\u5411\u7236\u7bc0\u9ede\u7684\u5c6c\u6027, \u7bc0\u9ede\u9593\u7684\u9023\u7d50\u662f\u55ae\u5411\u9084\u662f\u96d9\u5411\u95dc\u4fc2."}),"\n",(0,r.jsx)(n.p,{children:"\u5305\u542b\u7236\u7bc0\u9ede\u7684\u8cc7\u6599\u7d50\u69cb\u96d9\u5411\u9023\u7d50\u7684\u5c6c\u6027, \u5f9e\u4e8c\u5143\u6a39\u4e2d\u4efb\u4e00\u7bc0\u9ede\u5de1\u8a2a, \u7686\u53ef\u5b8c\u6574\u9084\u539f\u5b8c\u6574\u4e8c\u5143\u6a39\u7684\u8cc7\u6599.\n\u82e5\u6709\u9700\u8981, \u53ef\u4ee5\u5f9e\u4efb\u4f55\u4e00\u500b\u7bc0\u9ede\u958b\u59cb\u5c0b\u8a2a, \u7121\u9808\u6bcf\u4e00\u6b21\u90fd\u5fc5\u9808\u5f9e Root \u958b\u59cb\u5de1\u8a2a.\n\u4f46\u7576\u4fee\u6539\u4e8c\u5143\u6a39\u4e2d\u7684\u8cc7\u6599\u6642, \u9700\u8981\u6ce8\u610f\u7dad\u8b77\u7bc0\u9ede\u4e2d\u7684\u9023\u7d50\u95dc\u4fc2, \u5c24\u5176\u662f\u7236\u7bc0\u9ede\u7684\u9023\u7d50."}),"\n",(0,r.jsx)(n.p,{children:"\u800c\u4e0d\u5305\u542b\u7236\u7bc0\u9ede\u7684\u7d50\u69cb\u4e2d, API \u547c\u53eb\u57fa\u672c\u4e0a\u90fd\u5fc5\u9808\u5f9e Root \u958b\u59cb\u5de1\u8a2a.\n\u4f46\u76f8\u5c0d\u4fee\u6539\u8cc7\u6599\u6642, \u53ea\u9700\u8981\u8655\u7406\u5b50\u7bc0\u9ede\u7684\u55ae\u5411\u9023\u7d50\u95dc\u4fc2, \u7a0b\u5f0f\u7d50\u69cb\u90fd\u6bd4\u8f03\u7c21\u55ae."}),"\n",(0,r.jsx)(n.p,{children:"\u5169\u8005\u5404\u6709\u512a\u7f3a\u9ede, \u4f9d\u5be6\u52d9\u9700\u6c42\u6c7a\u5b9a. \u672c\u7bc7\u9078\u7528\u4e0d\u5305\u62ec\u7236\u9023\u7d50\u7684\u7d50\u69cb."}),"\n",(0,r.jsxs)(n.tabs,{children:["\n  ",(0,r.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type IBSTNode interface {\n  search(int) bool\n  insert(int)\n  remove(int) IBSTNode\n  findMin() int\n  findMax() int\n  findPredecessor(int) int\n  findSuccessor(int) int\n  inorder(*[]int)\n}\n\ntype BST struct {\n  root IBSTNode\n}\n\ntype BSTNode struct {\n  value int\n  left  *BSTNode\n  right *BSTNode\n}\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class BST {\n  constructor(data) {\n    this.root = null\n    if (typeof(data) === 'number') {\n      this.root = new BSTNode(data)\n    } else if (Array.isArray(data)) {\n      this.root = new BSTNode(data[0])\n      for (let i = 1; i < data.length; i++)\n        this.insert(data[i])\n    }\n  }\n}\n\nclass BSTNode {\n  constructor(data) {\n    this.value = data\n    this.left = null\n    this.right = null\n  }\n}\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export class BST {\n  root: BSTNode | null\n\n  constructor(data: number | Array<number> | null) {\n    this.root = null\n    if (typeof(data) === 'number') {\n      this.root = new BSTNode(data)\n    } else if (Array.isArray(data)) {\n      this.root = new BSTNode(data[0])\n      for (let i = 1; i < data.length; i++)\n        this.insert(data[i])\n    }\n  }\n}\n\ntype IBSTNode = BSTNode | null\nexport class BSTNode {\n  value: number\n  left: IBSTNode\n  right: IBSTNode\n\n  constructor(data: number) {\n    this.value = data\n    this.left = null\n    this.right = null\n  }\n}\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class BST:\n    def __init__(self, data):\n        self._root = None\n        if isinstance(data, int):\n            self._root = BSTNode(data)\n        elif isinstance(data, list):\n            self._root = BSTNode(data[0])\n            for i in range(1, len(data), 1):\n                self.insert(data[i])\n\nclass BSTNode:\n    def __init__(self, data):\n        self.value = data\n        self.left = None\n        self.right = None\n"})}),"\n  "]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"adt-basic-operate",children:"ADT Basic Operate"}),"\n",(0,r.jsx)(n.p,{children:"BST (and especially balanced BST like AVL Tree) is an efficient\ndata structure to implement a certain kind of Table (or Map)\nAbstract Data Type (ADT)."}),"\n",(0,r.jsx)(n.p,{children:"A Table ADT must support at least the following three operations\nas efficient as possible:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Search(v) \u2014 determine if v exists in the ADT or not,"}),"\n",(0,r.jsx)(n.li,{children:"Insert(v) \u2014 insert v into the ADT,"}),"\n",(0,r.jsx)(n.li,{children:"Remove(v) \u2014 remove v from the ADT."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"searchv",children:"Search(v)"}),"\n",(0,r.jsxs)(n.tabs,{children:["\n  ",(0,r.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func (n *BSTNode) search(val int) bool {\n  if n == nil { return false }\n  if n.value > val {\n    return n.left.search(val)\n  } else if n.value < val {\n    return n.right.search(val)\n  } else {\n    return true\n  }\n}\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  // class BSTNode\n  search(val) {\n    if (this.value === val)\n      return true\n    if (this.value > val)\n      return this.left === null ? false : this.left.search(val)\n    else\n      return this.right === null ? false : this.right.search(val)\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  // class BSTNode\n  public search(val: number): boolean {\n    if (this.value === val)\n      return true\n    if (this.value > val)\n      return this.left === null ? false : this.left.search(val)\n    else\n      return this.right === null ? false : this.right.search(val)\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"    # class BSTNode\n    def search(self, val):\n        if self.value == val:\n            return True\n        if val < self.value:\n            return False if self.left == None else self.left.search(val)\n        else:\n            return False if self.right == None else self.right.search(val)\n\n"})}),"\n  "]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"insertv",children:"Insert(v)"}),"\n",(0,r.jsxs)(n.tabs,{children:["\n  ",(0,r.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func (bst *BST) Insert(val int) {\n  if bst.root == nil { return }\n  bst.root = bst.root.insert(val)\n}\n\nfunc (n *BSTNode) insert(val int) IBSTNode {\n  return n.insertHelper(val)\n}\n\nfunc (n *BSTNode) insertHelper(val int) *BSTNode {\n  if n == nil { return newBSTNode(val) }\n\n  if val < n.value { n.left = n.left.insertHelper(val) } \n  else { n.right = n.right.insertHelper(val) }\n  return n\n}\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  // class BST\n  insert(val) {\n    if (this.root === null) return\n    this.root = this.root.insert(val)\n  }\n\n  // class BSTNode\n  insert(val) {\n    return BSTNode._insertHelper(val, this)\n  }\n\n  static _insertHelper(val, node) {\n    if (node === null) return new BSTNode(val)\n\n    if (val < node.value)\n      node.left = BSTNode._insertHelper(val, node.left)\n    else\n      node.right = BSTNode._insertHelper(val, node.right)\n    return node\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  // class BST\n  insert(val: number) {\n    if (this.root === null) return\n    this.root = this.root.insert(val)\n  }\n\n  // class BSTNode\n  public insert(val: number): IBSTNode {\n    return BSTNode.insertHelper(val, this)\n  }\n\n  static insertHelper(val: number, node: IBSTNode): IBSTNode {\n    if (node === null) return new BSTNode(val)\n\n    if (val < node.value)\n      node.left = BSTNode.insertHelper(val, node.left)\n    else\n      node.right = BSTNode.insertHelper(val, node.right)\n    return node\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"    # class BST\n    def insert(self, val):\n        if self._root is None:\n            self._root = BSTNode(val)\n        self._root = self._root.insert(val)\n\n    # class BSTNode\n    def insert(self, val):\n        return BSTNode.insert_helper(val, self)\n\n    @classmethod\n    def insert_helper(cls, val, node):\n        if node == None:\n            return BSTNode(val)\n\n        if val < node.value:\n            node.left = BSTNode.insert_helper(val, node.left)\n        else:\n            node.right = BSTNode.insert_helper(val, node.right)\n        return node \n"})}),"\n  "]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"removev",children:"Remove(v)"}),"\n",(0,r.jsxs)(n.tabs,{children:["\n  ",(0,r.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func (bst *BST) Remove(val int) {\n  if bst.root == nil { return }\n  bst.root = bst.root.remove(val)\n}\n\nfunc (n *BSTNode) remove(val int) IBSTNode {\n  return n.removeHelper(val)\n}\n\nfunc (n *BSTNode) removeHelper(val int) *BSTNode {\n  if n == nil { return nil }\n\n  if n.value > val {\n    n.left = n.left.removeHelper(val)\n  } else if n.value < val {\n    n.right = n.right.removeHelper(val)\n  } else {\n    if n.left != nil && n.right != nil {\n      successor := n.right.findMin()\n      n.value = successor\n      n.right = n.right.removeHelper(successor)\n    } else if n.left != nil {\n      n = n.left\n    } else if n.right != nil {\n      n = n.right\n    } else {\n      return nil\n    }\n  }\n  return n\n}\n\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  // class BST\n  remove(val) {\n    if (this.root === null) return\n    this.root = this.root.remove(val)\n  }\n\n  // class BSTNode\n  remove(val) {\n    return BSTNode._removeHelper(val, this)\n  }\n\n  static _removeHelper(val, node) {\n    if (node === null) return null\n\n    if (val < node.value) {\n      node.left = BSTNode._removeHelper(val, node.left)\n    } else if (node.value < val) {\n      node.right = BSTNode._removeHelper(val, node.right)\n    } else {\n      if ((node.left === null) && (node.right === null))\n        return null\n      else if (node.left === null)\n        result = node.right\n      else if (node.right === null)\n        result = node.left\n      else {\n        let successor = node.right.findMin()\n        node.value = successor\n        node.right = BSTNode._removeHelper(successor, node.right)\n      }\n    }\n    return node\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  // class BST\n  remove(val: number) {\n    if (this.root === null) return\n    this.root = this.root.remove(val)\n  }\n\n  // class BSTNode\n  public remove(val: number): IBSTNode {\n    return BSTNode.removeHelper(val, this)\n  }\n\n  static removeHelper(val: number, node: IBSTNode): IBSTNode {\n    if (node === null)\n      return null\n\n    if (val < node.value) {\n      node.left = BSTNode.removeHelper(val, node.left)\n    } else if (node.value < val) {\n      node.right = BSTNode.removeHelper(val, node.right)\n    } else {\n      if ((node.left === null) && (node.right === null))\n        return null\n      else if (node.left === null)\n        node = node.right\n      else if (node.right === null)\n        node = node.left\n      else {\n        let successor = node.right.findMin()\n        node.value = successor\n        node.right = BSTNode.removeHelper(successor, node.right)\n      }\n    }\n    return node\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"    # class BST\n    def remove(self, val):\n        if self._root is None:\n            return\n        self._root = self._root.remove(val)\n\n    # class BSTNode\n    def remove(self, val):\n        return BSTNode.remove_helper(val, self)\n\n    @classmethod\n    def remove_helper(cls, val, node):\n        if node == None:\n            return None\n\n        if val < node.value:\n            node.left = BSTNode.remove_helper(val, node.left)\n        elif node.value < val:\n            node.right = BSTNode.remove_helper(val, node.right)\n        else:\n            if node.left == None and node.right == None:\n                return None\n            elif node.left == None:\n                node = node.right\n            elif node.right == None:\n                node = node.left\n            else:\n                successor = node.right.find_min()\n                node.value = successor\n                node.right = BSTNode.remove_helper(successor, node.right)\n        return node\n"})}),"\n  "]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"find--travsal",children:"Find & Travsal"}),"\n",(0,r.jsx)(n.h3,{id:"min--max",children:"Min / Max"}),"\n",(0,r.jsxs)(n.tabs,{children:["\n  ",(0,r.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func (n *BSTNode) findMin() int {\n  if n.left == nil { return n.value } \n  else { return n.left.findMin() }\n}\n\nfunc (n *BSTNode) findMax() int {\n  if n.right == nil { return n.value } \n  else { return n.right.findMax() }\n}\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  findMin() {\n    return this.left === null ?  this.value : this.left.findMin()\n  }\n\n  findMax() {\n    return this.right === null ? this.value : this.right.findMax()\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  public findMin(): number {\n    return this.left === null ?  this.value : this.left.findMin()\n  }\n\n  public findMax(): number {\n    return this.right === null ? this.value : this.right.findMax()\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"    def find_min(self):\n        return self.value if self.left == None else self.left.find_min()\n\n    def find_max(self):\n        return self.value if self.right == None else self.right.find_max()-\n"})}),"\n  "]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"predecessor",children:"Predecessor"}),"\n",(0,r.jsxs)(n.tabs,{children:["\n  ",(0,r.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func (n *BSTNode) findPredecessor(val int) int {\n  predecessor := NOTFOUND\n  node := n\n  for node != nil && node.value != val {\n    if node.value < val {\n      predecessor = node.value\n      node = node.right\n    } else { node = node.left }\n  }\n  if node == nil { return NOTFOUND }\n  if node.left != nil { return node.left.findMax() } \n  else { return predecessor }\n}\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  findPredecessor(val) {\n    let predecessor = NOT_FOUND\n    let node = this\n    while ((node !== null) && (node.value !== val)) {\n      if (node.value < val) {\n        predecessor = node.value\n        node = node.right\n      } else \n        node = node.left\n    }\n    if (node === null)\n      return NOT_FOUND\n    if (node.left !== null)\n      return node.left.findMax()\n    else\n      return predecessor\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  public findPredecessor(val: number): number{\n    return BSTNode.findPredecessor(val, this)\n  }\n\n  static findPredecessor(val: number, currentNode: IBSTNode): number {\n    let predecessor = NOT_FOUND\n    let node = currentNode\n    while ((node !== null) && (node.value !== val)) {\n      if (node.value < val) {\n        predecessor = node.value\n        node = node.right\n      } else {\n        node = node.left\n      }\n    }\n\n    if (node === null)\n      return NOT_FOUND\n    if (node.left !== null)\n      return node.left.findMax()\n    else\n      return predecessor\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"    def find_predecessor(self, val):\n        predecessor = NOT_FOUND\n        node = self\n        while node != None and node.value != val:\n            if node.value < val:\n                predecessor = node.value\n                node = node.right\n            else:\n                node = node.left\n\n        if node == None:\n            return NOT_FOUND\n        if node.left != None:\n            return node.left.find_max()\n        else:\n            return predecessor\n"})}),"\n  "]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"successor",children:"Successor"}),"\n",(0,r.jsxs)(n.tabs,{children:["\n  ",(0,r.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func (n *BSTNode) findSuccessor(val int) int {\n  successor := NOTFOUND\n  node := n\n  for node != nil && node.value != val {\n    if node.value > val {\n      successor = node.value\n      node = node.left\n    } else { node = node.right }\n  }\n  if node == nil { return NOTFOUND }\n  if node.right != nil { return node.right.findMin() } \n  else { return successor }\n}\n\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  findSuccessor(val) {\n    let successor = NOT_FOUND\n    let node = this\n    while ((node !== null) && (node.value !== val)) {\n      if (node.value > val) {\n        successor = node.value\n        node = node.left\n      } else \n        node = node.right\n    }\n    if (node === null)\n      return NOT_FOUND\n    if (node.right !== null)\n      return node.right.findMin()\n    else\n      return successor\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  public findSuccessor(val: number): number{\n    return BSTNode.findSuccessor(val, this)\n  }\n\n  static findSuccessor(val: number, currentNode: IBSTNode): number {\n    let successor = NOT_FOUND\n    let node = currentNode\n    while ((node !== null) && (node.value !== val)) {\n      if (node.value > val) {\n        successor = node.value\n        node = node.left\n      } else {\n        node = node.right\n      }\n    }\n\n    if (node === null)\n      return NOT_FOUND\n    if (node.right !== null)\n      return node.right.findMin()\n    else\n      return successor\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"    def find_successor(self, val):\n        successor = NOT_FOUND\n        node = self\n        while node != None and node.value != val:\n            if val < node.value:\n                successor = node.value\n                node = node.left\n            else:\n                node = node.right\n\n        if node == None:\n            return NOT_FOUND\n        if node.right != None:\n            return node.right.find_min()\n        else:\n            return successor\n"})}),"\n  "]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"traversal",children:"Traversal"}),"\n",(0,r.jsx)(n.h3,{id:"deep-first-traversal",children:"Deep First Traversal"}),"\n",(0,r.jsx)(n.p,{children:"... TBD..."}),"\n",(0,r.jsx)(n.h3,{id:"inorder",children:"Inorder"}),"\n",(0,r.jsx)(n.p,{children:"An Inorder Traversal of this BST to obtain a list of sorted\nintegers inside this BST."}),"\n",(0,r.jsx)(n.p,{children:"Inorder Traversal is a recursive method whereby we visit\nthe left subtree first, exhausts all items in the left subtree,\nvisit the current root, before exploring the right subtree and\nall items in the right subtree."}),"\n",(0,r.jsxs)(n.tabs,{children:["\n  ",(0,r.jsxs)(n.tabitem,{value:"go",label:"Go",default:!0,children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func (bst *BST) Inorder() []int {\n  if bst.root == nil { return nil }\n  result := make([]int, 0)\n  bst.root.inorder(&result)\n  return result\n}\n\nfunc (n *BSTNode) inorder(buf *[]int) {\n  if n == nil { return }\n  n.left.inorder(buf)\n  *buf = append(*buf, n.value)\n  n.right.inorder(buf)\n}\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"js",label:"JavaScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  inorder() {\n    let result = []\n    if (this.left !== null)\n      result = result.concat(this.left.inorder())\n    result.push(this.value)\n    if (this.right !== null)\n      result = result.concat(this.right.inorder())\n    return result\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"ts",label:"TypeScript",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  public inorder(): Array<number> {\n    let result: Array<number> = new Array()\n    if (this.left !== null)\n      result = result.concat(this.left.inorder())\n    result.push(this.value)\n    if (this.right !== null)\n      result = result.concat(this.right.inorder())\n    return result\n  }\n"})}),"\n  "]}),"\n  ",(0,r.jsxs)(n.tabitem,{value:"python",label:"Python",children:["\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"    def inorder(self):\n        result = []\n        if self.left != None:\n            result.extend(self.left.inorder())\n        result.append(self.value)\n        if self.right != None:\n            result.extend(self.right.inorder())\n        return result\n"})}),"\n  "]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"\u5c0f\u7d50",children:"\u5c0f\u7d50"}),"\n",(0,r.jsxs)(n.p,{children:["\u548c ",(0,r.jsx)(n.a,{href:"/moco/bootcamp/algorithm/heap",children:"Binary Heap"})," \u76f8\u6bd4, BST \u4e2d\u7a0b\u5f0f\u905e\u8ff4\u53ef\u80fd\u6703\u4fee\u6539\u5230\u7269\u4ef6\u672c\u8eab.\n\u547c\u53eb\u548c\u56de\u50b3\u7684\u7269\u4ef6\u8655\u7406\u4e0a\u9700\u8981\u6bd4\u8f03\u6ce8\u610f."]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://visualgo.net/en/bst",children:"Binary Search Tree, AVL Tree - VisuAlgo"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://levelup.gitconnected.com/58f9126eb36b",children:"Binary Search Trees in Go. Introduction | by Puneeth S | Level Up Coding"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://arsenekuo.com/post/2021/12/13/implementation-of-bst-in-javascript",children:"\u7528 JavaScript \u5be6\u4f5c\u4e8c\u5143\u641c\u5c0b\u6a39\uff08Binary Search Tree\uff09 | Arsene's Alibi"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},11151:(e,n,l)=>{l.d(n,{Z:()=>a,a:()=>i});var r=l(67294);const t={},s=r.createContext(t);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);